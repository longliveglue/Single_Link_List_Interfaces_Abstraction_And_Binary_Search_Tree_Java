Data Structures with Abstract Classes: Linked Lists & Binary Search Trees

Learning Objective
Practice designing an abstract base class (ListItem) and implementing linked lists and binary search trees. Enforce sorting, insertion, and removal with compareTo, organizing data effectively.

Implement the following:
1.  ListItem (abstract class)
    -  It has three protected fields. Two ListItems called rightLink and leftLink, and an Object called value.
    -  A constructor that takes an Object and initializes the field value with the parameter that was passed in.
    -  And seven methods:
        -  next(), setNext(), previous(), setPrevious() and compareTo() which are package-private and abstract (see child class for declaration).
        -  getValue(), takes no parameters and returns its value.
        -  setValue(), takes an Object and assigns it to value.


2.  Node (concrete class)
    -  It extends ListItem.
    -  It has a constructor that takes an Object, then calls its parent constructor with the parameter that was passed in.
    -  And five methods which are package-private:
        -  next(), takes no parameters and returns the ListItem to its right.
        -  setNext(), takes a ListItem and sets it as its rightLink, then it returns rightLink.
        -  previous(), takes no parameters and returns the ListItem to its left.
        -  setPrevious(), takes a ListItem and sets it as its leftLink, then it returns leftLink.
        -  compareTo(), takes a ListItem and compares it to the ListItem that called this method. Use value from ListItem for comparison.
           If this value is greater than the value that was passed in, then it should return a number greater than …÷÷zero. 
	   If vice versa, then it should return a number less than zero, and zero if equal.


3.  MyLinkedList (concrete class)
    -  It implements NodeList.
    -  It has one field of type ListItem called root.
    -  A constructor that takes a ListItem and initializes the field root with the newly passed in parameter.
    -  And four methods:
        -  getRoot(), getter for root.
        -  addItem(), takes a ListItem and returns true if it was added successfully or false otherwise. If the item is already present, it doesn't get added. Use compareTo() to place the item in its proper order.
        -  removeItem(), takes a ListItem and returns true if it was removed successfully or false otherwise.
        -  traverse(), takes the root as an argument and does not return anything. If the root is null it prints out: The list is empty, otherwise print each value on a separate line.


4.  NodeList (interface)
    -  It has four methods:
        -  getRoot(), addItem(), removeItem() and traverse() which are package-private and abstract (see child class for declaration).



5.  SearchTree (concrete class)
    -  It implements NodeList.
    -  It has one field of type ListItem called root.
    -  A constructor that takes a ListItem and initializes the field root with the newly passed in parameter.
    -  And five methods:
        -  getRoot(), getter for root.
        -  addItem(), similar to MyLinkedList. See second TIP below.
        -  removeItem(), same as MyLinkedList.
        -  performRemoval(), takes two ListItems, the item to be removed and its parent. It doesn't return anything and is declared as private. Call this method from removeItem() when the item is found.
        -  traverse(), takes the root as an argument and does not return anything. It uses recursion to visit all the branches in the tree (Inorder). Print each value on a seperate line.


TIP:  The rules for adding an item to the linked tree are:
          If the head of the tree is null, make the head refer to the item to be added.
          If the item to be added is less than the current item in the tree, add the item before the current item (i.e., make the previous item's "next" refer to the new item, and the new item's "next" refer to the current item).
          If the item to be added is greater than the current item, move onto the next item and compare again (if there is no next item, then that is where the new item belongs).
TIP:  When adding items to a Binary Search Tree, if the item to be added is less than the current item, then move to the left.
         If it is greater than the current item, then move to the right.
         The new item is added when an attempt to move in the required direction would involve following a null reference.
         Once again, duplicates are not allowed.
TIP:  Inorder = print the previous node, then the parent node, and then the next node (left -> node -> right).

TIP:  Be extremely careful with the spelling of the names of the fields, constructors and methods.
TIP:  Be extremely careful about spaces and spelling in the printed output from the traverse() method.

NOTE:  All fields are private (unless stated otherwise).
NOTE:  All constructors are public.
NOTE:  All methods are public (unless stated otherwise).
NOTE:  Do not add a main method to the solution code.


Code to compare against.

public abstract class ListItem {
    protected ListItem rightLink;
    protected ListItem leftLink;
    protected Object value;

    public ListItem(Object value) {
        this.value = value;
    }

    abstract ListItem next();
    abstract ListItem setNext(ListItem rightLink);
    abstract ListItem previous();
    abstract ListItem setPrevious(ListItem leftLink);
    abstract int compareTo(ListItem other);

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
}

public class Node extends ListItem {
    public Node(Object value) {
        super(value);
    }

    @Override
    ListItem next() {
        return rightLink;
    }

    @Override
    ListItem setNext(ListItem rightLink) {
        return this.rightLink = rightLink;
    }

    @Override
    ListItem previous() {
        return leftLink;
    }

    @Override
    ListItem setPrevious(ListItem leftLink) {
        return this.leftLink = leftLink;
    }

    /* If this value is greater than the value that was passed in, then it
    should return a number greater than zero. If vice versa, then it
    should return a number less than zero, and zero if equal. */
    @Override
    int compareTo(ListItem other) {
        int x = Integer.parseInt(String.valueOf(value));
        int y = Integer.parseInt(String.valueOf(other.value));
        if (x == y) {
            return 0;
        }
        return x > y ? 1 : -1;
    }
}


public class MyLinkedList implements NodeList {
    private ListItem root;

    public MyLinkedList(ListItem root) {
        this.root = root;
    }

    @Override
    public ListItem getRoot() {
        return root;
    }

    @Override
    public boolean addItem(ListItem node) {
        // the list is empty so the item becomes the head of the list
        if (root == null) {
            root = node;
            return true;
        }

        ListItem current = root;
        while (true) {
            // if there is no next item, we insert this item at the end of the list
            if (current.next() == null) {
                current.setNext(node);
                node.setPrevious(current);
                return true;
            }
            // if there is a next item and new item is smaller, insert this item before current
            if (current.compareTo(node) == 1) {
                root = node;
                root.setNext(current);
                current.setPrevious(root);
                return true;
            }
            return false;
        }
    }

    @Override
    public boolean removeItem(ListItem node) {
        if (root == null || node == null) {
            return false;
        }
        while (true) {
            if (node.compareTo(root) == 0) {
                root.previous().setNext(null);
                return true;
            }

            root = root.next();
            if (root == null) {
                return false;
            }
        }
    }

    @Override
    public void traverse(ListItem root) {
        if (root == null) {
            System.out.print("The list is empty");
        }
        while (root != null) {
            System.out.println(root.getValue());
            root = root.next();
        }
    }
}

public interface NodeList {
    abstract ListItem getRoot();
    abstract boolean addItem(ListItem node);
    abstract boolean removeItem(ListItem node);
    abstract void traverse(ListItem root);
}


public class SearchTree implements NodeList {
    private ListItem root;

    public SearchTree(ListItem root) {
        this.root = root;
    }

    @Override
    public ListItem getRoot() {
        return root;
    }

    @Override
    public boolean addItem(ListItem node) {
        // If the head of the tree is null, make the head refer to the item to be added.
        if (root == null) {
            root = node;
            return true;
        }

        ListItem current = root;
        while (true) {
            // equal
            if (current.compareTo(node) == 0) {
                return false;
            }
            // node is smaller, add the item before the current item
            else if (current.compareTo(node) == 1) {
                current.setPrevious(node);
                return true;
            }
            // node is greater and (if there is no next item, then that is where the new item belongs)
            else if (current.next() == null) {
                current.setNext(node);
                return true;
            }
            // node is greater and next not null, move onto the next item and compare again
            current = current.next();
        }
    }

    @Override
    public boolean removeItem(ListItem node) {
        if (node == null || root == null) {
            return false;
        }

        ListItem previous = null;
        while (true) {
            if (node.compareTo(root) == 0) {
                performRemoval(node, previous);
                return true;
            }

            if (root.next() == null) {
                return false;
            }
            previous = root;
            root = root.next();
        }
    }

    // Call performRemoval() from removeItem() when the item is found
    private void performRemoval(ListItem itemToRemove, ListItem parent) {
        // Item to remove has no right child
        if (itemToRemove.next() == null) {
            // itemToRemove is the right child of the parent
            if (parent.next() == itemToRemove) {
                parent.setNext(itemToRemove.previous());
            }
            // itemToRemove is the left child of the parent
            else if (parent.previous() == itemToRemove) {
                parent.setPrevious(itemToRemove.previous());
            }
            // itemToRemove is the root
            else {
                root = itemToRemove.previous();
            }
        }
        // Item to remove has no left child
        else if (itemToRemove.previous() == null) {
            // itemToRemove is the right child of the parent
            if (parent.next() == itemToRemove) {
                parent.setNext(itemToRemove.next());
            }
            // itemToRemove is the left child of the parent
            else if (parent.previous() == itemToRemove) {
                parent.setPrevious(itemToRemove.next());
            }
            // itemToRemove is the root
            else {
                root = itemToRemove.next();
            }
        }
        // Item to remove has both left and right children
        else {
            ListItem current = itemToRemove.next();
            ListItem leftMostParent = itemToRemove;

            while (current.previous() != null) {
                leftMostParent = current;
                current = current.previous();
            }

            itemToRemove.setValue(current.getValue());

            if (leftMostParent == itemToRemove) {
                itemToRemove.setNext(current.next());
            } else {
                leftMostParent.setPrevious(current.next());
            }
        }
    }

    @Override
    public void traverse(ListItem root) {
        // Inorder = left -> node -> right
        if (root == null) {
            return;
        }
        traverse(root.previous());
        System.out.println(root.getValue());
        traverse(root.next());
    }
}